---
title: 堆排序
date: 2016-09-05 22:01:57
updated: 2016-09-05 22:02:01
categories: [Reading, 算法]
tags: [java, 排序, 数组]
---

# 堆

n个元素的序列{k1, k2, ..., kn}称之为堆，当且仅当满足以下条件时:

<!-- more -->

大根堆：<img src="http://www.forkosh.com/mathtex.cgi? \Large k_i \ge k_{2i} \&\& k_i \ge k_{2i+1}"/>

或

小根堆：<img src="http://www.forkosh.com/mathtex.cgi? \Large k_i \le k_{2i} \&\& k_i \le k_{2i+1}"/>

# 排序思想

1. **建初堆**：按堆的定义将待排序列**r[1..n]**调整为大根堆，交换r[1]和r[n]，则r[n]为关键字最大的记录；
2. **调整堆**：将r[1..n-1]重新调整为堆，交换r[1]和r[n-1]，则r[n-1]为关键字次大的记录；
3. **循环n-1次**，直到交换了r[1]和r[2]为止，得到了一个非递减的有序序列r[1..n]。

# 示例

将无序序列{49, 38, 65, 97, 76, 13, 27, 49}进行堆排序。

**1.** 筛选法建立大根堆，从最后一个非叶子节点（n/2）开始筛选

- `97`满足，`65`满足
- (1)→(2)：`38`不满足，`49`→`97`，`97`→`38`，`38`→`49`
- (2)→(3)：`49`不满足，`76`→`97`，`97`→`49`，`49`→`76`


```
      49                  49                  97
  ┌───┴───┐           ┌───┴───┐           ┌───┴───┐
  38      65          97      65          76      65
┌─┴─┐   ┌─┴─┐       ┌─┴─┐   ┌─┴─┐       ┌─┴─┐   ┌─┴─┐
97  76  13  27      49  76  13  27      49  49  13  27
│                   │                   │
49                  38                  38
     (1)                 (2)                 (3)
```


**2.** 调整堆

- (3)→(4)：交换，`97`←→`38`，`97`为最大值节点
- (4)→(5)：调整根节点，`49`→`76`，`76`→`38`，`38`→`49`
- (5)→(6)：交换，`76`←→`27`，`76`为次大值节点
- (6)→(7)：调整根节点...
- (7)→(8)：交换...
- ...

```
      97                  38                  76                  27
  ┌───┴───┐           ┌───┴───┐           ┌───┴───┐           ┌───┴───┐
  76      65          76      65          49      65          49      65
┌─┴─┐   ┌─┴─┐       ┌─┴─┐   ┌─┴─┐       ┌─┴─┐   ┌─┴─┐       ┌─┴─┐   ┌─┴─×
49  49  13  27      49  49  13  27      38  49  13  27      38  49  13  76
│                   ×                   ×                   ×
38                  97                  97                  97
     (3)                 (4)                 (5)                 (6)

      65                  13                  49                  13
  ┌───┴───┐           ┌───┴───┐           ┌───┴───┐           ┌───┴───┐
  49      27          49      27          49      27          49      27
┌─┴─┐   ┌─┴─×       ┌─┴─┐   ×─┴─×       ┌─┴─┐   ×─┴─×       ┌─┴─×   ×─┴─×
38  49  13  76      38  49  65  76      38  13  65  76      38  49  65  76
×                   ×                   ×                   ×
97                  97                  97                  97
     (7)                 (8)                 (9)                 (10)

      49                  13                  38                  27
  ┌───┴───┐           ┌───┴───┐           ┌───┴───┐           ┌───┴───×
  38      27          38      27          13      27          13      38
┌─┴─×   ×─┴─×       ×─┴─×   ×─┴─×       ×─┴─×   ×─┴─×       ×─┴─×   ×─┴─×
97  49  65  76      49  49  65  76      49  49  65  76      49  49  65  76
×                   ×                   ×                   ×
97                  97                  97                  97
     (12)                (12)                (13)                (14)

      27                  13
  ┌───┴───×           ×───┴───×
  13      38          27      38
×─┴─×   ×─┴─×       ×─┴─×   ×─┴─×
49  49  65  76      49  49  65  76
×                   ×
97                  97
     (15)                (16)
```

# Java实现

```java
/**
 * 堆排序
 * @param list
 */
public static void heapSort(List<Integer> list){
	createHeap(list);
	for(int i=list.size()-1;i>0;i--){
		// 交换第0个与第i个节点
		Integer temp =list.get(0);
		list.set(0, list.get(i));
		list.set(i, temp);
		// 调整堆
		adjustHeap(list, 0, i-1);
	}
}

/**
 * 建初堆
 * @param list
 */
public static void createHeap(List<Integer> list){
	int l = list.size();
	for(int i=l/2-1; i>=0; i--){ // 最后一个非叶子节点开始，调整至根节点
		adjustHeap(list, i, l-1);
	}
}

/**
 * 筛选法调整堆
 * @param list
 * @param m 待调整节点的下标
 * @param n 最后一个未调整节点的下标
 */
public static void adjustHeap(List<Integer> list, int m, int n){
	Integer temp = list.get(m);
	for(int i=2*m+1;i<=n;i=i*2+1){
		if(i<n&&list.get(i)<list.get(i+1)){ // 左右子节点选出较大节点
			i++;
		}
		if(temp>=list.get(i)){ // 均不小于左右子节点，无需调整
			break;
		}
		list.set(m, list.get(i));
		m = i; //记录子节点下标，继续迭代
	}
	list.set(m, temp); // 最终位置插入节点
}

public static void main(String[] args){
	Integer[] array = {49, 38, 65, 97, 76, 13, 27, 49};
	List<Integer> list = Arrays.asList(array);
	heapSort(list);
	System.out.println(list.toString());
}
```

# 总结

**时间复杂度**：最好、最坏、平均均为：$$ O(nlog_2n) $$

**特点：**

- 不稳定
- 只能用于顺序结构，不能用于链式结构
- 初始建堆所需的比较次数较多，因此记录数较少时不宜采用。
